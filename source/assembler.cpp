
#include <fstream>
#include <iostream>
#include "../include/die.h"
#include "../include/run.h"
#include "../include/file.h"
#include "../include/locate.h"
#include "../include/options.h"
#include "../include/assembler.h"
#include "../include/management.h"

using namespace std;

void process_token(const TokenList& tokens, unsigned int& index, bool& terminate_needed, string& output, ofstream& write, unsigned int& indentation){
    // Terminate
    if(tokens[index].id == TOKENINDEX_TERMINATE and terminate_needed){
        output += ";\n";
        terminate_needed = false;
    }
    else { // Other tokens

        if(tokens[index].id == TOKENINDEX_STRING_LITERAL){
            output += "boomslang_String(\"" + tokens[index].data + "\")";
        }
        else if(tokens[index].id == TOKENINDEX_NUMERIC_LITERAL){
            output += "boomslang_Number(" + tokens[index].data + ")";
        }
        else if(tokens[index].id == TOKENINDEX_WORD){
            string name = tokens[index].data;

            output += resource(name);
            terminate_needed = true;
        }
        else if(tokens[index].id == TOKENINDEX_METHOD_CALL){
            output += "." + resource(tokens[index].data);
        }
        else if(tokens[index].id == TOKENINDEX_OPEN){
            output += "(";
        }
        else if(tokens[index].id == TOKENINDEX_CLOSE){
            output += ")";
        }
        else if(tokens[index].id == TOKENINDEX_INDENT){
            indentation++;
        }
        else if(tokens[index].id == TOKENINDEX_DEDENT){
            indentation--;
        }
        else if(tokens[index].id == TOKENINDEX_KEYWORD){
            if(tokens[index].data == "on"){
                string return_value = "void";
                string method_name;
                string method_code;
                unsigned int before_indentation = indentation; // The indentation before processing tokens in method
                unsigned int token_indent = indentation + 1;    // The indentation during processing

                index++;
                method_name = tokens[index].data;
                index += 5;

                while(before_indentation != token_indent){
                    process_token(tokens, index, terminate_needed, method_code, write, token_indent);
                    index++;
                }

                write << return_value + " " + resource(method_name) + "(){\n" + method_code + "}\n";
            }
        }
        else if(tokens[index].id == TOKENINDEX_ADDRESS){
            output += "&";
        }
        else if(tokens[index].id == TOKENINDEX_MEMBER){
            output += ".";
        }
        else if(tokens[index].id == TOKENINDEX_NEXT){
            output += ",";
        }
        else if(tokens[index].id == TOKENINDEX_ADDRESSMEMBER){
            output += "->";
        }
        else if(tokens[index].id == TOKENINDEX_NOT){
            output += "!";
        }

        terminate_needed = true;
    }
}

void compile(Configuration* config, const TokenList& tokens){
    // Writes resulting c++ source code

    ofstream write( (HOME + CPP_SOURCE).c_str() );
    bool terminate_needed = false;
    string global;

    // Ensure file(s) are open
    if(!write.is_open()){
        die("Failed to open source file(s)");
    }

    // Write Header
    write << "/*This file was generated by Boomslang, modify at your own risk*/\n\n#include \"../core/boomslangcore.h\"\n\nint* argc;\nchar*** argv;\n\n";

    unsigned int indentation;

    // Process tokens
    for(unsigned int index = 0; index < tokens.size(); index++){
        process_token(tokens, index, terminate_needed, global, write, indentation);
    }

    // Write Main
    write << "int main(int _agc, char** _agv){\nargc = &_agc;\nargv = &_agv;\nboomslang_main();\nreturn 0;\n}\n";
    write.close();
}

void build(Configuration* config){
    // Builds the executable/package

    string compile_flags = "-std=c++11 ";
    string linker_flags;

    #if defined(__WIN32__)
    //Compile without console unless specified

    if (!config->console){
        linker_flags += "-Wl,--subsystem,windows ";
    }

    if (!config->optimize){
        linker_flags += "-O3 ";
    }

    if(file_exists( ("C:\\Users\\" + USERNAME + "\\AppData\\Roaming\\Boomslang\\source\\source.o") )){
        if(remove( ("C:\\Users\\" + USERNAME + "\\AppData\\Roaming\\Boomslang\\source\\source.o").c_str() )!=0){
            die("Failed to delete object file");
        }
    }

    { //Run MinGW
        bool bad = execute_silent("C:\\Users\\" + USERNAME + "\\AppData\\Roaming\\Boomslang\\resources\\MinGW\\bin\\g++","-c \"C:\\Users\\" + USERNAME + "\\AppData\\Roaming\\Boomslang\\source\\source.cpp\" " + compile_flags + " -o \"" + "C:\\Users\\" + USERNAME + "\\AppData\\Roaming\\Boomslang\\source\\source.o" + "\" 2>\"C:\\Users\\" + USERNAME + "\\AppData\\Roaming\\Boomslang\\logs\\native_errors.log\"");

        if(bad) die("Native Compiler Error");
    }

    if(config->package){
        //execute_silent("C:\\Users\\" + USERNAME + "\\AppData\\Roaming\\Boomslang\\resources\\MinGW\\bin\\ar","rvs \"C:\\Users\\" + USERNAME + "\\AppData\\Roaming\\Boomslang\\source\\final.a\" \"C:\\Users\\" + USERNAME + "\\AppData\\Roaming\\Boomslang\\source\\final.o\" \"C:\\Users\\" + USERNAME + "\\AppData\\Roaming\\Boomslang\\core\\libboomslangcore.a\" " + linker_flags + " 2>\"C:\\Users\\" + USERNAME + "\\AppData\\Roaming\\Boomslang\\logs\\linker_errors.log\"");
        //branch_create(filename_path(file_read_name) + filename_change_ext(filename_name(file_read_name),"branch"),"C:\\Users\\" + USERNAME + "\\AppData\\Roaming\\Boomslang\\source\\final.a","C:\\Users\\" + USERNAME + "\\AppData\\Roaming\\Boomslang\\source\\final.h","C:\\Users\\" + USERNAME + "\\AppData\\Roaming\\Boomslang\\source\\final.boomslang");
    }
    else {
        bool bad = execute_silent("C:\\Users\\" + USERNAME + "\\AppData\\Roaming\\Boomslang\\resources\\MinGW\\bin\\g++","\"C:\\Users\\" + USERNAME + "\\AppData\\Roaming\\Boomslang\\source\\source.o\" " + linker_flags + "\"C:\\Users\\" + USERNAME + "\\AppData\\Roaming\\Boomslang\\core\\libboomslangcore.a\" -o \"" +  config->output_filename + "\" 2>\"C:\\Users\\" + USERNAME + "\\AppData\\Roaming\\Boomslang\\logs\\linker_errors.log\"");

        if(bad) die("Native Compiler Error");
    }

    if(config->run){
        system(("\"" + config->output_filename + "\"").c_str());
    }
    #endif

    cout << "Successfully Built '" + filename_name(config->output_filename) + "'" << endl;
}

void assemble(Configuration* config, const TokenList& tokens){
    // Creates executable/package from code

    // Write source code
    compile(config, tokens);

    // Build the result
    build(config);
}
